#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <inttypes.h>
#include <errno.h>
#include <sys/stat.h>
#include <dirent.h>
#include <sys/socket.h>
#include <arpa/inet.h>

#include "esp_log.h"
#include "esp_err.h"
#include "esp_timer.h"
#include "esp_spiffs.h"
#include "driver/i2c.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/semphr.h"
#include "esp_netif.h"
#include "esp_event.h"
#include "nvs_flash.h"
#include "esp_http_server.h"
#include "esp_wifi.h"
#include "lwip/ip_addr.h"
#include "lwip/sockets.h"

#define I2C_MASTER_NUM        I2C_NUM_0
#define I2C_MASTER_SDA_IO     21
#define I2C_MASTER_SCL_IO     22
#define I2C_MASTER_FREQ_HZ    100000
#define I2C_MASTER_TIMEOUT_MS 1000

#define MPU6050_ADDR              0x68
#define MPU6050_PWR_MGMT_1_REG    0x6B
#define MPU6050_ACCEL_XOUT_H_REG  0x3B
#define ACCEL_SCALE_FACTOR        16384.0f

// Лог-файл в SPIFFS, монтированном в корень
#define LOG_FILE   "/accel_log.txt"

static const char *TAG = "MPU6050_LOG";

static SemaphoreHandle_t spiffs_mutex;
static SemaphoreHandle_t recording_mutex;
static volatile bool recording = false;

// Прототипы
static void               i2c_scan(void);
static esp_err_t          i2c_master_init(void);
static esp_err_t          mpu6050_write_reg(uint8_t, uint8_t);
static esp_err_t          mpu6050_read_bytes(uint8_t, uint8_t*, size_t);
static esp_err_t          mpu6050_init(void);
static esp_err_t          init_spiffs(void);
static esp_err_t          start_webserver(void);
static void               sensor_task(void*);
static esp_err_t          log_handler(httpd_req_t*);
static void               wifi_event_handler(void*, esp_event_base_t, int32_t, void*);
static void               wifi_init_softap(void);

// I2C scan
static void i2c_scan(void) {
    ESP_LOGI(TAG, "Scanning I2C bus…");
    for (uint8_t addr = 1; addr < 127; addr++) {
        i2c_cmd_handle_t cmd = i2c_cmd_link_create();
        i2c_master_start(cmd);
        i2c_master_write_byte(cmd, (addr<<1)|I2C_MASTER_WRITE, true);
        i2c_master_stop(cmd);
        if (i2c_master_cmd_begin(I2C_MASTER_NUM, cmd, pdMS_TO_TICKS(100)) == ESP_OK) {
            ESP_LOGI(TAG, " – Device @ 0x%02X", addr);
        }
        i2c_cmd_link_delete(cmd);
    }
}

// I2C init
static esp_err_t i2c_master_init(void) {
    i2c_config_t conf = {
        .mode = I2C_MODE_MASTER,
        .sda_io_num = I2C_MASTER_SDA_IO,
        .scl_io_num = I2C_MASTER_SCL_IO,
        .sda_pullup_en = GPIO_PULLUP_ENABLE,
        .scl_pullup_en = GPIO_PULLUP_ENABLE,
        .master.clk_speed = I2C_MASTER_FREQ_HZ
    };
    ESP_ERROR_CHECK(i2c_param_config(I2C_MASTER_NUM, &conf));
    return i2c_driver_install(I2C_MASTER_NUM, conf.mode, 0, 0, 0);
}

// MPU6050 write reg
static esp_err_t mpu6050_write_reg(uint8_t reg, uint8_t data) {
    uint8_t buf[2] = {reg, data};
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    esp_err_t ret = i2c_master_start(cmd)
                  | i2c_master_write_byte(cmd, (MPU6050_ADDR<<1)|I2C_MASTER_WRITE, true)
                  | i2c_master_write(cmd, buf, 2, true)
                  | i2c_master_stop(cmd)
                  | i2c_master_cmd_begin(I2C_MASTER_NUM, cmd, pdMS_TO_TICKS(I2C_MASTER_TIMEOUT_MS));
    i2c_cmd_link_delete(cmd);
    return ret;
}

// MPU6050 read bytes
static esp_err_t mpu6050_read_bytes(uint8_t reg, uint8_t *data, size_t len) {
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    esp_err_t ret = i2c_master_start(cmd)
                  | i2c_master_write_byte(cmd, (MPU6050_ADDR<<1)|I2C_MASTER_WRITE, true)
                  | i2c_master_write_byte(cmd, reg, true)
                  | i2c_master_start(cmd)
                  | i2c_master_write_byte(cmd, (MPU6050_ADDR<<1)|I2C_MASTER_READ, true);
    if (len > 1) ret |= i2c_master_read(cmd, data, len-1, I2C_MASTER_ACK);
    ret |= i2c_master_read_byte(cmd, data+len-1, I2C_MASTER_NACK)
        | i2c_master_stop(cmd)
        | i2c_master_cmd_begin(I2C_MASTER_NUM, cmd, pdMS_TO_TICKS(I2C_MASTER_TIMEOUT_MS));
    i2c_cmd_link_delete(cmd);
    return ret;
}

static esp_err_t mpu6050_init(void) {
    return mpu6050_write_reg(MPU6050_PWR_MGMT_1_REG, 0x00);
}

// Init SPIFFS — монтируем в корень
static esp_err_t init_spiffs(void) {
    esp_vfs_spiffs_conf_t conf = {
        .base_path              = "/",        // монтируем прямо в /
        .partition_label        = "spiffs",   // label из partitions.csv
        .max_files              = 5,
        .format_if_mount_failed = true
    };
    esp_err_t ret = esp_vfs_spiffs_register(&conf);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "SPIFFS mount failed: %s", esp_err_to_name(ret));
        return ret;
    }
    size_t total = 0, used = 0;
    ret = esp_spiffs_info(conf.partition_label, &total, &used);
    if (ret == ESP_OK) {
        ESP_LOGI(TAG, "SPIFFS mounted: total=%u bytes, used=%u bytes", total, used);
    } else {
        ESP_LOGE(TAG, "SPIFFS info failed: %s", esp_err_to_name(ret));
    }
    return ESP_OK;
}

// HTTP /log handler
static esp_err_t log_handler(httpd_req_t *req) {
    if (xSemaphoreTake(spiffs_mutex, pdMS_TO_TICKS(2000))) {
        FILE *f = fopen(LOG_FILE, "r");
        if (!f) {
            ESP_LOGE(TAG, "fopen(%s) failed: errno=%d", LOG_FILE, errno);
            httpd_resp_send_404(req);
            xSemaphoreGive(spiffs_mutex);
            return ESP_FAIL;
        }
        char buf[128];
        size_t r;
        while ((r = fread(buf,1,sizeof(buf),f)) > 0) {
            httpd_resp_send_chunk(req, buf, r);
        }
        fclose(f);
        httpd_resp_send_chunk(req, NULL, 0);
        xSemaphoreGive(spiffs_mutex);
        return ESP_OK;
    }
    ESP_LOGE(TAG, "SPIFFS mutex timeout");
    httpd_resp_send_500(req);
    return ESP_FAIL;
}

static const httpd_uri_t log_uri = {
    .uri      = "/log",
    .method   = HTTP_GET,
    .handler  = log_handler,
    .user_ctx = NULL
};

static esp_err_t start_webserver(void) {
    httpd_config_t cfg = HTTPD_DEFAULT_CONFIG();
    cfg.lru_purge_enable  = true;
    cfg.max_open_sockets  = 5;
    httpd_handle_t serv = NULL;
    if (httpd_start(&serv, &cfg) != ESP_OK) {
        ESP_LOGE(TAG, "HTTP start failed");
        return ESP_FAIL;
    }
    httpd_register_uri_handler(serv, &log_uri);
    ESP_LOGI(TAG, "HTTP server running");
    return ESP_OK;
}

static void wifi_event_handler(void* arg, esp_event_base_t eb, int32_t ei, void* ed) {
    if (ei == WIFI_EVENT_AP_STACONNECTED) {
        wifi_event_ap_staconnected_t* e = (wifi_event_ap_staconnected_t*) ed;
        ESP_LOGI(TAG, "Station connected: %02x:%02x:%02x:%02x:%02x:%02x",
                 e->mac[0],e->mac[1],e->mac[2],
                 e->mac[3],e->mac[4],e->mac[5]);
    }
}

static void wifi_init_softap(void) {
    ESP_ERROR_CHECK(nvs_flash_init());
    ESP_ERROR_CHECK(esp_netif_init());
    ESP_ERROR_CHECK(esp_event_loop_create_default());
    esp_netif_t* ap = esp_netif_create_default_wifi_ap();
    assert(ap);
    wifi_init_config_t ic = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&ic));
    ESP_ERROR_CHECK(esp_event_handler_register(WIFI_EVENT,ESP_EVENT_ANY_ID,
                                               wifi_event_handler,NULL));
    wifi_config_t wc = {
        .ap = {
            .ssid = "ESP32_AP",
            .password = "esp32password",
            .max_connection = 4,
            .authmode = WIFI_AUTH_WPA_WPA2_PSK,
            .pmf_cfg = {.required=false}
        }
    };
    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP));
    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_AP, &wc));
    ESP_ERROR_CHECK(esp_wifi_start());
    esp_netif_ip_info_t ip;
    IP4_ADDR(&ip.ip,192,168,4,1);
    IP4_ADDR(&ip.gw,192,168,4,1);
    IP4_ADDR(&ip.netmask,255,255,255,0);
    esp_netif_dhcps_stop(ap);
    ESP_ERROR_CHECK(esp_netif_set_ip_info(ap,&ip));
    ESP_ERROR_CHECK(esp_netif_dhcps_start(ap));
    ESP_LOGI(TAG, "WiFi AP started: SSID=%s", wc.ap.ssid);
}

static void sensor_task(void* pv) {
    FILE *f = NULL;
    uint32_t start_us = 0;
    const float GYRO_SCALE = 131.0f;

    while (1) {
        uint8_t d[14];
        if (mpu6050_read_bytes(MPU6050_ACCEL_XOUT_H_REG,d,sizeof(d))!=ESP_OK) {
            ESP_LOGE(TAG,"MPU6050 read failed");
            vTaskDelay(pdMS_TO_TICKS(100));
            continue;
        }
        float ax = ((int16_t)((d[0]<<8)|d[1]))/ACCEL_SCALE_FACTOR;
        float ay = ((int16_t)((d[2]<<8)|d[3]))/ACCEL_SCALE_FACTOR;
        float az = ((int16_t)((d[4]<<8)|d[5]))/ACCEL_SCALE_FACTOR;
        float tot = sqrtf(ax*ax + ay*ay + az*az);

        if (xSemaphoreTake(recording_mutex,pdMS_TO_TICKS(1000))) {
            if (tot>2.5f && !recording) {
                recording=true;
                start_us=esp_timer_get_time();
                ESP_LOGI(TAG,"Recording started");
                if (xSemaphoreTake(spiffs_mutex,pdMS_TO_TICKS(1000))) {
                    ESP_LOGI(TAG,"Opening %s for write",LOG_FILE);
                    f=fopen(LOG_FILE,"w");
                    if (!f) ESP_LOGE(TAG,"fopen(%s) failed: errno=%d",LOG_FILE,errno);
                    else {
                        fprintf(f,"{\"start_time\":%"PRIu32"}\n",start_us);
                        fflush(f);
                    }
                    xSemaphoreGive(spiffs_mutex);
                }
            }
            xSemaphoreGive(recording_mutex);
        }

        if (recording) {
            uint32_t now=esp_timer_get_time();
            if (now-start_us<=30000000) {
                float gx=((int16_t)((d[8]<<8)|d[9]))/GYRO_SCALE;
                float gy=((int16_t)((d[10]<<8)|d[11]))/GYRO_SCALE;
                float gz=((int16_t)((d[12]<<8)|d[13]))/GYRO_SCALE;
                char line[256];
                snprintf(line,sizeof(line),
                    "{\"t\":%"PRIu32",\"ax\":%.3f,\"ay\":%.3f,\"az\":%.3f"
                    ",\"gx\":%.2f,\"gy\":%.2f,\"gz\":%.2f}\n",
                    now-start_us,ax,ay,az,gx,gy,gz);
                if (xSemaphoreTake(spiffs_mutex,pdMS_TO_TICKS(1000))) {
                    if (f) { fprintf(f,"%s",line); fflush(f); }
                    xSemaphoreGive(spiffs_mutex);
                }
            } else {
                recording=false;
                if(f){ fclose(f); f=NULL; }
                ESP_LOGI(TAG,"Recording stopped");
            }
        }
        vTaskDelay(pdMS_TO_TICKS(10));
    }
}

void app_main(void) {
    spiffs_mutex    = xSemaphoreCreateMutex();
    recording_mutex = xSemaphoreCreateMutex();
    if (!spiffs_mutex||!recording_mutex) {
        ESP_LOGE(TAG,"Mutex creation failed");
        return;
    }
    ESP_ERROR_CHECK(i2c_master_init());
    i2c_scan();
    ESP_ERROR_CHECK(mpu6050_init());
    ESP_ERROR_CHECK(init_spiffs());
    wifi_init_softap();
    ESP_ERROR_CHECK(start_webserver());
    xTaskCreate(sensor_task,"sensor",4096,NULL,5,NULL);
    ESP_LOGI(TAG,"System initialized");
}
